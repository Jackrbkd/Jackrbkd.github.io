<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>algorithm-1</title>
    <url>/2022/08/30/algorithm-1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>study,cs</category>
      </categories>
      <tags>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>android-1</title>
    <url>/2022/09/02/android-1/</url>
    <content><![CDATA[<p>无限通讯技术发展</p>
<p>● 从1G到5G</p>
<p>无限通讯：传输电磁波</p>
<p>频率越来越高，波长越来越小(波长越来越小就要求基站越来越多才OK，5G很烧钱！)</p>
<p>基站越来越密</p>
<p>1G(1985)：模拟信号，只能通话</p>
<p>2G(1990)：数字信号(32Kbps)，语音和短信，支持GSM小规模数据传输</p>
<p>3G()：较高频宽(2Mbps)，蜂窝网络，3G移动通讯标准，TD-SCDMA多媒体通讯</p>
<p>4G()：高频宽(100Mbps)，全方位网络</p>
<p>5G()：超高频宽(2.5Gbps)，物联网，整合物联网的全新网络</p>
<p>● 安卓系统和苹果系统</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>开发平台</th>
<th>开发理念</th>
<th>运行机制</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>安卓</td>
<td>Linux</td>
<td>免费、开源</td>
<td>无法强制限制内存资源使用</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>苹果</td>
<td>Unix</td>
<td>收费、闭源</td>
<td>严格控制内存使用(墓碑机制、沙盒机制)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>● 移动应用程序开发趋势</p>
<p>Android</p>
<p>三大优势：开放性；定制化；免费用</p>
<p>开发趋势：</p>
<p>系统碎片化：ROM定制</p>
<p>屏幕碎片化：适配尺寸</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>compile-2</title>
    <url>/2022/09/01/compile-2/</url>
    <content><![CDATA[<h1 id="文法和语言的概念和表示"><a href="#文法和语言的概念和表示" class="headerlink" title="文法和语言的概念和表示"></a>文法和语言的概念和表示</h1><h2 id="预备知识—形式语言基础"><a href="#预备知识—形式语言基础" class="headerlink" title="预备知识—形式语言基础"></a>预备知识—形式语言基础</h2><h2 id="文法的非形式讨论"><a href="#文法的非形式讨论" class="headerlink" title="文法的非形式讨论"></a>文法的非形式讨论</h2><h3 id="●-文法："><a href="#●-文法：" class="headerlink" title="● 文法："></a>● 文法：</h3><p>​    文法是对语言结构的定义与描述。即从形式上用于描述和规定语言结构的称为“文法”(或称为“语法”)。</p>
<p>◇ 文法是在形式上对句子结构的定义与描述，不涉及语义问题。</p>
<h3 id="●-语法规则："><a href="#●-语法规则：" class="headerlink" title="● 语法规则："></a>● 语法规则：</h3><p>​    描述句子语法结构的规则。规定用“::=”表示“由……组成”。</p>
<p>&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</p>
<p>&lt;主语&gt;::=&lt;代词&gt;|&lt;名词&gt;</p>
<p>&lt;代词&gt;::=你|我|他</p>
<h3 id="●-由规则推导句子："><a href="#●-由规则推导句子：" class="headerlink" title="● 由规则推导句子："></a>● 由规则推导句子：</h3><p>​    可以按照语法规则来推导或产生句子。</p>
<p>◇ 推导方法：从一个要识别的符号开始推导，即用相应规则的右部来代替规则的左部，每次仅用一条规则去进行推导，直到所有符号被终结符号替代为止。</p>
<p>◇ 最左推导：有若干语法成分同时存在时，我们总是从最左部分进行推导，这称之为最左推导。最右推导同理。</p>
<h3 id="●-语法树："><a href="#●-语法树：" class="headerlink" title="● 语法树："></a>● 语法树：</h3><p>​    语法树用来描述一个句子的语法结构</p>
<p>◇ 语法成分：&lt;&gt;，在形式语言中又称”非终结符“</p>
<p>◇ 单词符号：在形式语言中又称“终结符号”</p>
<h2 id="文法和语言的形式定义"><a href="#文法和语言的形式定义" class="headerlink" title="文法和语言的形式定义"></a>文法和语言的形式定义</h2><h3 id="文法："><a href="#文法：" class="headerlink" title="文法："></a>文法：</h3><p>​    文法G = ($V_n,V_t,P,Z$),</p>
<p>$V_n$ : 非终结符号集</p>
<p>$V_t$ : 终结符号集    #V = $V_n \cup V_t$称为文法的字汇表 </p>
<p>P : 产生式或规则的集合    </p>
<h1 id="规则是一个有序对-U-x-，通常写为U-x或U→x，-U-1-x-geq-0-U-in-V-n-x-in-V"><a href="#规则是一个有序对-U-x-，通常写为U-x或U→x，-U-1-x-geq-0-U-in-V-n-x-in-V" class="headerlink" title="规则是一个有序对(U,x)，通常写为U::=x或U→x，|U| = 1 |x| $\geq$ 0 , $U\in V_n,x\in V^*$"></a>规则是一个有序对(U,x)，通常写为U::=x或U→x，|U| = 1 |x| $\geq$ 0 , $U\in V_n,x\in V^*$</h1><p>Z : 开始符号(识别符号)    #$Z\in V_n$</p>
<h3 id="直接推导"><a href="#直接推导" class="headerlink" title="直接推导"></a>直接推导</h3><p>文法G：v = xUy,    w = xuy</p>
<p>其中x、y$\in V_<em>,u \in V_n, u \in V^</em>$</p>
<p>若U::=u$\in P$，则$v\underset{G}{\Rightarrow}w$.</p>
<p>若x = y = $\xi$，有U::=u，则$U\underset{G}{\Rightarrow}u$   #啥意思？感觉多此一举。。。</p>
<h3 id="间接推导"><a href="#间接推导" class="headerlink" title="间接推导"></a>间接推导</h3><p>文法G，$U_0,U_1,U_2,…,U_n \in V^+$</p>
<p>if $v \underset{G}{\Rightarrow} U_0 \underset{G}{\Rightarrow} U_1 \underset{G}{\Rightarrow} U_2 \underset{G}{\Rightarrow} … \underset{G}{\Rightarrow} U_n \underset{G}{\Rightarrow} w$,则$v \stackrel{+}{\underset{G}{\Rightarrow}} w$</p>
<h3 id="v-stackrel-underset-G-Rightarrow-w"><a href="#v-stackrel-underset-G-Rightarrow-w" class="headerlink" title="$v \stackrel{*}{\underset{G}{\Rightarrow}} w$"></a>$v \stackrel{*}{\underset{G}{\Rightarrow}} w$</h3><p>文法G，v、w$\in V^+$，</p>
<p>if $v \stackrel{+}{\underset{G}{\Rightarrow}} w$，或 v = w，则$v \stackrel{*}{\underset{G}{\Rightarrow}} w$</p>
<h3 id="规范推导"><a href="#规范推导" class="headerlink" title="规范推导"></a>规范推导</h3><p>有$xUy \Rightarrow xuy$，if $y \in V_t^*$，则此推导为规范的，记为$x<br>Uy \nRightarrow xuy$   #ppt中斜杠似乎为竖直杠</p>
<p>直观意义：规范推导 = 最右推导 </p>
<h3 id="文法G-Z"><a href="#文法G-Z" class="headerlink" title="文法G[Z]"></a>文法G[Z]</h3><p>句型：x是句型 &lt;=&gt; Z $\stackrel{<em>}{\Rightarrow}$ x，且$x \in V^</em>$；</p>
<p>句子：x是句子 &lt;=&gt; Z $\stackrel{+}{\Rightarrow}$ x，且x$\in V_t^* $;    </p>
<!--注意句子和句型的区别在哪，一个是间接推导&带星推导，一个是字汇表克林闭包&终结符号集克林闭包-->
<p>语言：L(G[Z]) = {x | x $\in V_t^*$，Z$\stackrel{+}{\Rightarrow}$x}；</p>
<h3 id="等价文法"><a href="#等价文法" class="headerlink" title="等价文法"></a>等价文法</h3><p>G和$G^,$是两个不同的文法，若L(G) = L($G^,$),则G和$G^,$称为等价文法</p>
<!--一个文法对应一个语言，但是一个语言不一定对应一个文法-->
<h3 id="递归文法"><a href="#递归文法" class="headerlink" title="递归文法"></a>递归文法</h3><h4 id="递归规则"><a href="#递归规则" class="headerlink" title="递归规则"></a>递归规则</h4><p>规则右部有与左部相同的符号，</p>
<p>对于U::=xUy，若x=$\xi$，即U::=Uy，左递归；</p>
<p>若y = $\xi$，即U::=xU，右递归</p>
<h4 id="递归文法-1"><a href="#递归文法-1" class="headerlink" title="递归文法"></a>递归文法</h4><p>● 文法G，存在U$\in V_n$，</p>
<p>​    if U$\stackrel{+}{\Rightarrow}$…U…，则G为递归文法(自迁入递归)；</p>
<p>​    if U$\stackrel{+}{\Rightarrow}$U…，则G为左递归文法；</p>
<p>​    if U$\stackrel{+}{\Rightarrow}$…U，则G为右递归文法。</p>
<p>● 左递归文法的缺点：</p>
<p>​    不能用自顶向下的方法来进行语法分析</p>
<p>● 递归文法的优点：</p>
<p>​    可用有穷条规则，定义无穷语言</p>
<h3 id="句型的短语、简单短语和句柄"><a href="#句型的短语、简单短语和句柄" class="headerlink" title="句型的短语、简单短语和句柄"></a>句型的短语、简单短语和句柄</h3><h3 id="短语-amp-简单短语"><a href="#短语-amp-简单短语" class="headerlink" title="短语&amp;简单短语"></a>短语&amp;简单短语</h3><p>给定文法G[Z]，w = xuy$\in V^+$，为该文法的句型，</p>
<p>若Z$\stackrel{*}{\Rightarrow}$xUy，且U$\stackrel{+}{\Rightarrow}$u，则u是句型w相对于U的短语；</p>
<p>若Z$\stackrel{*}{\Rightarrow}$xUy，且U$\Rightarrow$u，则u是句型w相对于U的简单短语；</p>
<p>其中U$\in V_n, u\in V^+, x,y\in V^*$</p>
<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>任一句型的最左简单短语称为该句型的句柄</p>
<!--句柄对一个句型只能有一个，简单短语呢？-->
]]></content>
      <categories>
        <category>study,cs</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp-1</title>
    <url>/2022/08/30/cpp-1/</url>
    <content><![CDATA[<p>动态内存分配 malloc/free，堆栈 stack/heap</p>
<p>函数指针 pfn ， bsearch，qsort</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="对齐问题"><a href="#对齐问题" class="headerlink" title="对齐问题"></a>对齐问题</h2><p>● 对齐特性：按照最大对齐，可通过#pragma pack(n)修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">double</span> j;</span><br><span class="line">   <span class="type">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line">size:<span class="number">24</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">int</span> k;</span><br><span class="line">   <span class="type">double</span> j;</span><br><span class="line">&#125;;</span><br><span class="line">size:<span class="number">16</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1) <span class="comment">/*意思是将一个字节作为最小限制单位，即无气泡*/</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">int</span> k;</span><br><span class="line">   <span class="type">double</span> j;</span><br><span class="line">&#125;;</span><br><span class="line">size:<span class="number">16</span></span><br></pre></td></tr></table></figure>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>● 有些信息在存储时，并不需要占用一个完整的字节，而只需占几个二进制位(如“开关”)。c语言为此提供了一个数据结构，称为“位域”/“位段”。</p>
<p>● “位域”是把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按照域名进行操作。</p>
<h3 id="●-位域的定义和结构变量的说明"><a href="#●-位域的定义和结构变量的说明" class="headerlink" title="● 位域的定义和结构变量的说明"></a>● 位域的定义和结构变量的说明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 位域结构名</span><br><span class="line">&#123;</span><br><span class="line">    位域列表 <span class="comment">/* type [member_name] : width ; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<p>​    type只能为int，unsigned int，signed int三种类型。 <!--char好像也行？--></p>
<p>​    member_name是位域的名称</p>
<p>​    width是位域中位的数量，宽度必须小于或等于<em>指定类型</em>的位宽度</p>
<h3 id="●-一些说明"><a href="#●-一些说明" class="headerlink" title="● 一些说明"></a>● 一些说明</h3><p>◇ 一个位域存储在同一个字节中，如果一个字节所剩空间不够存放另一位域时，会从下一单元起存放位域，也可以有意使位域从下一单元开始，如使用空域 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bs</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="type">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="type">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>◇ 位域的宽度不能超过它所依附数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，<code>:</code>后面的数字不能超过这个长度。</p>
<p>◇ 位域可以是无名位域，用于填充和调整位置，无名位域不能使用。</p>
<p>进一步了解见<a href="https://www.runoob.com/cprogramming/c-bit-fields.html">C 位域 | 菜鸟教程 (runoob.com)</a>，<a href="https://blog.csdn.net/sty124578/article/details/79456405">(16条消息) 位域的定义和使用<em>Unix探索之旅的博客-CSDN博客</em>位域定义</a>，但要注意其中内容有错。</p>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><h2 id="常数宏"><a href="#常数宏" class="headerlink" title="常数宏"></a>常数宏</h2><p>● 定义一个常数，消除神仙数</p>
<p>● 建议多多使用，增加程序的可读性</p>
<h2 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a>函数宏</h2><p>● 保持程序结构化，消除函数调用开销</p>
<p>● 不建议经常使用，容易出问题，加括号又会导致结果过于繁琐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在c++程序编译的过程中，会先把所有的宏直接替换成相应的代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a,b) a+b</span></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">ADD</span>(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">/* --&gt; int i = 4+5;*/</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">ADD</span>(<span class="number">4</span>,<span class="number">5</span>) * <span class="number">3</span>; <span class="comment">/* --&gt; int j = 4+5*3 */</span></span><br></pre></td></tr></table></figure>
<h2 id="控制宏"><a href="#控制宏" class="headerlink" title="控制宏"></a>控制宏</h2><p>● 开关：用来适应不同的环境，只需要在宏中定义即可，而不需要每次修改代码中每一处，多用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*比如，如果我们自己开发要用一个sql，客户要用另一个sql，那么我们可以这样做，而不需要每次进行大量的修改*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL_VER</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local server:mysql&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;customer server:oracle&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*再比如，如果我们想在windows环境下进行某项操作，我们可以如下操作,WIN32是一个在windows系统中会自动定义的宏*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="C-如何调用C函数"><a href="#C-如何调用C函数" class="headerlink" title="C++如何调用C函数"></a>C++如何调用C函数</h1><p>● 直接调用会出错</p>
<p>● 因为在编译过程中程序会将变量什么的修饰成新的名称，c++认为cfunction是c++的函数，所以按照c++的格式修饰，但是cfunction其实是c程序，所以按照修饰之后的名称去找，找不到cfunction</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cfunction</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>● 修改方法为告诉程序这个函数是C程序，但是这样会(没太听清，好像是函数多了会比较麻烦)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">cfunction</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>● 所以我们还可以这样，无论是一个函数，还是多个函数，只需要加一次这段宏即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;c&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cfunction</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>● 记住，要在头尾用两次ifdef，而不要直接将整段包在中间，包在中间会导致在c环境下失去这些定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;c&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cfunction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>compile1_basic</title>
    <url>/2022/08/29/compile-1-basic/</url>
    <content><![CDATA[<h1 id="源程序—-gt-目标程序：翻译程序"><a href="#源程序—-gt-目标程序：翻译程序" class="headerlink" title="源程序—&gt;目标程序：翻译程序"></a>源程序—&gt;目标程序：翻译程序</h1><p>翻译程序：汇编程序/编译程序</p>
<p>汇编程序：汇编语言—&gt;机器语言，此时翻译程序称之为汇编程序，翻译过程称之为“汇编”</p>
<p>编译程序：高级语言—&gt;目标程序，此时翻译过程称之为“编译”</p>
<h1 id="解释程序：对源程序进行解释执行的程序"><a href="#解释程序：对源程序进行解释执行的程序" class="headerlink" title="解释程序：对源程序进行解释执行的程序"></a>解释程序：对源程序进行<em>解释执行</em>的程序</h1><p>一般来说，从源程序到输出最终的结果有三种路径。</p>
<p>FirstPath : 源程序经过翻译程序转换为目标程序；数据输入到目标程序+运行时库程序，获得输出</p>
<p>SecondPath：将数据和源程序都输入到解释程序中，获得输出</p>
<p>ThirdPath：源程序通过编译程序转换为源程序的中间形式；之后将数据和源程序的中间形式作为输入，获得输出</p>
<h1 id="编译过程：将高级语言程序翻译为语义等价的目标程序的过程"><a href="#编译过程：将高级语言程序翻译为语义等价的目标程序的过程" class="headerlink" title="编译过程：将高级语言程序翻译为语义等价的目标程序的过程"></a>编译过程：将高级语言程序翻译为语义等价的目标程序的过程</h1><p>●五个基本阶段：词法分析—&gt;语法分析—&gt;语义分析、生成中间代码—&gt;代码优化—&gt;生成目标程序</p>
<h2 id="词法分析：分析和识别单词"><a href="#词法分析：分析和识别单词" class="headerlink" title="词法分析：分析和识别单词"></a>词法分析：分析和识别单词</h2><p>●单词：是语言的基本语法单位，一般语言有四大类单词</p>
<pre><code>&lt;1&gt;语言定义的关键字或保留字（如BEGIN、END、IF）

&lt;2&gt;标识符

&lt;3&gt;常数

&lt;4&gt;分界符（运算符） （如+、-、*、/、;、（、） ……）
</code></pre><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>●根据语法规则（即语言的文法），分析并识别出各种语法成分，如表达式、各种说明、各种语句、过程、函数等，</p>
<pre><code>并进行语法正确性检查。
</code></pre><h2 id="语义分析、生成中间代码"><a href="#语义分析、生成中间代码" class="headerlink" title="语义分析、生成中间代码"></a>语义分析、生成中间代码</h2><p>●对识别出的各种语法成分进行语义分析，并产生相应的中间代码</p>
<p>●中间代码：一种介于源语言和目标语言之间的中间语言形式</p>
<pre><code>目的：便于做优化处理；便于编译程序的移植

形式：四元式、三元式、逆波兰表示

四元式（三地址指令）：？
</code></pre><h2 id="代码优化：得到高质量的目标程序"><a href="#代码优化：得到高质量的目标程序" class="headerlink" title="代码优化：得到高质量的目标程序"></a>代码优化：得到高质量的目标程序</h2><h2 id="生成目标程序-保持语义等价性"><a href="#生成目标程序-保持语义等价性" class="headerlink" title="生成目标程序(保持语义等价性)"></a>生成目标程序(保持语义等价性)</h2><p>●由中间代码很容易生成目标程序（地址指令序列）。</p>
<pre><code>这部分工作与机器关系密切 ，所以要根据机器进行。

在做这部分工作时（要注意充分利用目标机特性），也可以进行优化处理。
</code></pre><h1 id="编译程序构造"><a href="#编译程序构造" class="headerlink" title="编译程序构造"></a>编译程序构造</h1><h2 id="编译程序的逻辑结构"><a href="#编译程序的逻辑结构" class="headerlink" title="编译程序的逻辑结构"></a>编译程序的逻辑结构</h2><p>●按逻辑功能不同，可将编译过程划分为五个基本阶段，与此相对应，我们将实现整个编译过程的编译程序划分为五个逻辑阶段（即五个逻辑子过程）。</p>
<p>●在上面五个阶段中都要做两件事：建表和查表；出错处理</p>
<p>●符号表管理</p>
<pre><code>及时地把源程序中的信息和编译过程中产生的信息记在表格中，在随后的编译过程中要不断查找这些表格中的信息。
</code></pre><p>●出错处理</p>
<pre><code>诊察错误并报告用户错误的性质和位置
</code></pre><p>●综上，典型的编译程序应该有七个逻辑部分：</p>
<pre><code>符号表管理+出错处理

词法分析程序--&gt;语法分析程序--&gt;语义分析、生成中间代码--&gt;代码优化程序--&gt;生成目标程序
</code></pre><h1 id="遍"><a href="#遍" class="headerlink" title="遍"></a>遍</h1><p>●对源程序(包括源程序中间形式)从头到尾扫描次，并作有关的加工处理，生成新的源程序中间形式或目标程序，通常称之为一遍</p>
<p>●一遍扫描编译程序：一遍扫描即可完成整个编译工作的成为一遍扫描编译程序</p>
<h2 id="遍vs基本阶段"><a href="#遍vs基本阶段" class="headerlink" title="遍vs基本阶段"></a>遍vs基本阶段</h2><p>●五个基本阶段：将源程序翻译为目标程序在逻辑上要完成的工作</p>
<p>●遍：完成上面五个基本阶段的工作，要经过几次扫描处理</p>
<h1 id="前端和后端"><a href="#前端和后端" class="headerlink" title="前端和后端"></a>前端和后端</h1><p>●编译程序根据功能分为前端和后端</p>
<p>●前端：与源程序有关的编译部分。</p>
<pre><code>           词法分析、语法分析、语义分析、中间代码生成    ---分析部分

           feature：与*源语言*有关
</code></pre><p>●后端：与目标机有关的部分</p>
<pre><code>            代码优化、目标代码生成

            feature：与*目标机*有关
</code></pre><h1 id="编译程序的前后处理器"><a href="#编译程序的前后处理器" class="headerlink" title="编译程序的前后处理器"></a>编译程序的前后处理器</h1><p>●源程序：多文件、宏定义和宏调用，包含文件</p>
<p>●目标程序：一般为汇编程序或可重定位的机器代码</p>
<p>●流程：?</p>
<p>框架源程序—&gt;源程序(预处理器，替换宏etc)</p>
<p><em>源程序</em>—&gt;目标程序(编译程序)</p>
<p>目标程序—&gt;<em>可重定位机器码Obj文件</em>(汇编程序)    #源程序通过编译程序可直接转换为可重定位机器码Obj文件</p>
<p>可重定位机器码文件组—&gt;可执行程序，exe、a.out…(链接，库目标、可重定位目标文件)</p>
<p>可执行程序，exe、a.out…—&gt;可运行的及其代码(加载器)</p>
<h1 id="编译技术的应用"><a href="#编译技术的应用" class="headerlink" title="编译技术的应用"></a>编译技术的应用</h1><p>●语法制导的结构化编辑器</p>
<p>●程序格式化工具</p>
<p>●软件测试工具</p>
<p>●程序理解工具</p>
<p>●高级语言的翻译工具</p>
<p>●etc</p>
]]></content>
      <categories>
        <category>study,cs</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>database_1</title>
    <url>/2022/08/30/database-0-intro/</url>
    <content><![CDATA[<h1 id="数据-amp-信息"><a href="#数据-amp-信息" class="headerlink" title="数据&amp;信息"></a>数据&amp;信息</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>●描述现实世界各种事物的可以识别的符号</p>
<p>●有数字、文字、图形、图像、音视频等多种表现或存储形式</p>
<p>●只有被组织和加工成信息，才具有使用价值</p>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>●信息是一种已经被加工为特定形式的数据，这些数据对现在和将来的决策有明显价值</p>
<p>●信息是各种数据所包含的意义</p>
<p>●数据是信息的载体，是信息的具体表现形式</p>
<h1 id="数据处理-amp-数据管理"><a href="#数据处理-amp-数据管理" class="headerlink" title="数据处理&amp;数据管理"></a>数据处理&amp;数据管理</h1><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>●从大量原始数据中抽取和推导出有价值信息的加工过程</p>
<p>●包括 ： 数据收集、组织、存储、加工、分类、检索、输出、传输等操作</p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>●数据处理一般性的基本操作</p>
<p>●如数据分类、组织、存储、检索、维护</p>
<p>●研究专门的技术——数据管理技术</p>
<h3 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术"></a>数据库技术</h3><p>●是一种数据管理技术</p>
<p>●按照某种数据结构对数据进行组织后，存储在计算机的二级存储中，可以提供数据共享操作</p>
<p>●软件实现：数据库管理系统DBMS</p>
<p>●数据库系统：基于数据库管理系统(DBMS)建立的具有特定数据处理功能的系统</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>数据库系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>database-1-basic</title>
    <url>/2022/08/30/database-1-basic/</url>
    <content><![CDATA[<h1 id="数据管理技术的发展"><a href="#数据管理技术的发展" class="headerlink" title="数据管理技术的发展"></a>数据管理技术的发展</h1><h2 id="人工管理阶段"><a href="#人工管理阶段" class="headerlink" title="人工管理阶段"></a>人工管理阶段</h2><p>● 时间：20世纪50年代以前</p>
<p>● 背景：</p>
<p>​    - 外存仅磁带、卡片、纸带，没有磁盘等直接存取设备</p>
<p>​    - 没有操作系统和数据管理软件，用户用机器指令编码</p>
<p>​    - 计算机主要用于科学计算</p>
<p>● 特点：</p>
<p>​    - 数据不在计算机上保存</p>
<p>​    - 没有软件系统对数据进行管理，程序规定数据的逻辑结构和物理结构，数据和程序不具有独立性</p>
<p>​    - 基本没有文件概念，数据组织方式必须由程序员自行设计</p>
<p>​    - 一组数据对应一个程序，数据是面向应用的，程序间不能共享数据</p>
<h2 id="文件系统阶段"><a href="#文件系统阶段" class="headerlink" title="文件系统阶段"></a>文件系统阶段</h2><p>● 时间：20世纪50年代后期到60年代中期</p>
<p>● 背景：</p>
<p>​    - 外存出现磁盘、磁鼓等直接存取设备</p>
<p>​    - 出现专门管理数据的软件，一般称为文件系统，包括在操作系统中</p>
<p>​    - 计算机不但用于科学计算，还用于管理</p>
<p>● 特点：</p>
<p>​    - 数据以文件形式保留在外存上</p>
<p>​    - 文件多样化</p>
<p>​    - 数据的存取基本上以记录为单位</p>
<p>​    - 程序和数据有<em>一定的</em>独立性（指物理独立，逻辑不独立）// mark一下，不理解欸</p>
<p>​    - 文件和应用程序基本上是一一对应，数据共享性差，冗余度大</p>
<p>● 问题：文件分散、相互独立，数据冗余度大，数据和程序缺乏独立性</p>
<p>​    - 存储空间浪费</p>
<p>​    - 容易造成数据的不一致性</p>
<p>​    - 数据维护难度大</p>
<p>​    - 程序维护工作量大</p>
<h2 id="数据库系统阶段"><a href="#数据库系统阶段" class="headerlink" title="数据库系统阶段"></a>数据库系统阶段</h2><p>● 数据库技术要解决的基本问题</p>
<p><em>集成</em>数据的表示</p>
<p>统一管理下的数据<em>共享</em></p>
<p>● 解决基本问题的核心技术</p>
<p>数据模型</p>
<p>数据独立性 —&gt; 共享</p>
<p>● 面向全组织的复杂的数据结构</p>
<p>在描述数据时，不仅描述数据本身，还要描述数据之间的联系，使整个组织的数据结构化</p>
<p>数据结构化是数据库的主要特征之一，是数据库和文件系统的根本区别。</p>
<p>● 数据冗余度小，易扩充</p>
<p>● 具有较高的数据和程序的独立性</p>
<p>数据独立性：</p>
<p>数据的物理独立性：数据的存储结构(物理结构)改变时，数据的逻辑结构可以不变，从而应用程序也不必改变</p>
<p>数据的逻辑独立性：数据的逻辑结构改变时，应用程序可以不变</p>
<p>● 统一的数据控制功能</p>
<p>数据的安全性控制：</p>
<p>保护数据以防止不合法的使用所造成数据的泄密和破坏</p>
<p>数据的完整性控制：</p>
<p>指数据的正确性和相容性(一致)</p>
<p>并发控制：</p>
<p>● 数据模型用来抽象和表示现实世界中的数据和信息：</p>
<p>描述对象</p>
<p>描述与表示的目标</p>
<p>现实世界业务 —&gt;(数据的认识、抽象) 信息世界信息(概念模型)    </p>
<!--概念模型：又称信息模型，用于信息世界建模，是现实世界到信息世界的持续，是用户和数据库设计人员继续交流的语言-->
<p>信息世界信息(概念模型) —&gt;(转换) 机器世界数据(数据模型)</p>
<!--数据模型用于机器世界，按计算机系统的观点对数据建模，如层次、网状、关系模型-->
<p>概念模型基于信息世界的主要概念，表达应用中的各种语义；</p>
<p>具有较强的语义表达能力，能够方便、直接表达应用中的各种语义</p>
<p>概念模型应该简单、清晰、易于理解</p>
<p>概念模型最常用的表示方法：实体-联系方法(E-R法)</p>
<p>实体(Entity)：客观存在并可相互区分的食物</p>
<p>属性(Attribute)：客体所具有的某一特性</p>
<p>码(Key)：唯一标识实体的<em>属性</em>集</p>
<p>域(Domain)：某个(些)属性的取值范围</p>
<p>实体型(Entity Type)：表示一类实体，用实体名及其属性名集合来抽象、刻画</p>
<p>联系(Relation)：实体型之间的联系，是实体之间的相互关联</p>
<p>名称</p>
<p>类型：</p>
<p>​    一对一联系(1:1)</p>
<p>​    一对多联系(1:n)</p>
<p>​    多对多联系(m:n)</p>
<p>可以具有属性</p>
<p>E-R图的组成：实体、联系、属性</p>
<p>实体：长方形，框内写实体名</p>
<p>属性：椭圆形，<em>无向边</em>连接实体和属性(码：一个属性的时候，在属性名下划线；多个属性时，弧线连接<em>无向边</em>，在上面标注”\\“)</p>
<p>联系：菱形表示实体间的联系，菱形框内写上联系名。用无向边</p>
<p>同一个实体集内部个实体之间也可以存在一对一、一对多、多对多的联系。</p>
<p>三个或多个实体型间可能存在某种联系</p>
<p>存在依赖：</p>
<p>子女实体存在依赖于职工实体的存在，则称子女实体是弱实体</p>
<p>标识依赖：</p>
<p>如果实体不能由它自己的属性来唯一标识，而必须通过与它相联系的另一实体一起来标识，那么称该实体标识依赖于另一个实体</p>
<p>实体的子集：</p>
<p>子类可继承父类的属性，子类也可以附加某些实现</p>
<p>子类之间的交不一定为空</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>数据库系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title>formal_language-1</title>
    <url>/2022/08/31/formal-language-1/</url>
    <content><![CDATA[<h1 id="课程概述及预备知识"><a href="#课程概述及预备知识" class="headerlink" title="课程概述及预备知识"></a>课程概述及预备知识</h1><h2 id="形式文法与自动机理论的发展"><a href="#形式文法与自动机理论的发展" class="headerlink" title="形式文法与自动机理论的发展"></a>形式文法与自动机理论的发展</h2><h3 id="形式语言定义"><a href="#形式语言定义" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>● 自然语言：英语、汉语</p>
<p>● 符号语言：程序设计语言、标记语言、算法等</p>
<p>● 形式语言 — 元语言：</p>
<p>​    用<em>数学方法</em>将<em>符号语言</em>抽象成一个<em>数学系统</em>，对其进行严格的<em>形式化定义</em>，并构建适当的<em>描述模型</em>，发展相关的知识和理论，使之在科学实践中具有良好的指导作用。</p>
<h3 id="形式语言概况"><a href="#形式语言概况" class="headerlink" title="形式语言概况"></a>形式语言概况</h3><h4 id="N-Chosky-1956-首次形式语言研究自然语言"><a href="#N-Chosky-1956-首次形式语言研究自然语言" class="headerlink" title="N.Chosky,1956(首次形式语言研究自然语言)"></a>N.Chosky,1956(首次形式语言研究自然语言)</h4><p>● 形式文法派生语言：</p>
<p>字母表：一组有限多个符号构成集合A</p>
<p>语言L：A中所有符号串构成集合A*，A*每一个子集可视为A上一个语言L</p>
<p>一个语言L(所有句子)可以按照文法G<sub>L</sub>的一系列描述规则(算法)形式化地派生出来。</p>
<p>● 派生符号语言的Chomsky文法体系：</p>
<p>0型文法：短语结构文法或无限制文法</p>
<p>1型文法：上下文有关文法</p>
<p>2型文法：上下文无关文法</p>
<p>3型文法：正则文法</p>
<h4 id="识别符号语言的A-Turing自动机体系"><a href="#识别符号语言的A-Turing自动机体系" class="headerlink" title="识别符号语言的A.Turing自动机体系"></a>识别符号语言的A.Turing自动机体系</h4><h5 id="图灵机TM"><a href="#图灵机TM" class="headerlink" title="图灵机TM"></a>图灵机TM</h5><p>● 能根据内部状态，在一个无限长磁带上进行读、写、移动等简单操作，计算所有可计算的函数；是模拟九三级算法的计算逻辑和研究可计算性的形式化描述工具。</p>
<p>● 两个基本性质：</p>
<p>计算对象能用有穷方式描述</p>
<p>计算过程必须由一系列离散的、可以机械执行的步骤执行</p>
<h5 id="DFA、NFA、PDA"><a href="#DFA、NFA、PDA" class="headerlink" title="DFA、NFA、PDA"></a>DFA、NFA、PDA</h5><h4 id="N-乔姆斯基证明等价性"><a href="#N-乔姆斯基证明等价性" class="headerlink" title="N.乔姆斯基证明等价性"></a>N.乔姆斯基证明等价性</h4><p>● 证明文法和自动机的等价性，文法和自动机分别从派生和识别角度表达语言，开启了用数学方法研究形式语言的先河。</p>
<p>● 两种计算模型的对应关系：</p>
<p>​    0型文法（无限制文法） &lt; — &gt; 图灵机</p>
<p>​    1型文法（上下文有关文法） &lt; — &gt; 线性有界自动机</p>
<p>​    2型文法（上下文无关文法） &lt; — &gt; 下推自动机</p>
<p>​    3型文法（正则文法） &lt; — &gt; 有穷状态自动机</p>
<h4 id="Amir将自动机和逻辑建立关系"><a href="#Amir将自动机和逻辑建立关系" class="headerlink" title="Amir将自动机和逻辑建立关系"></a>Amir将自动机和逻辑建立关系</h4><p>● Amir Pnueli 将自动机和逻辑建立关系，基于此发展了模型检测技术</p>
<h3 id="计算模型相关研究领域"><a href="#计算模型相关研究领域" class="headerlink" title="计算模型相关研究领域"></a>计算模型相关研究领域</h3><h4 id="可计算性问题的提出"><a href="#可计算性问题的提出" class="headerlink" title="可计算性问题的提出"></a>可计算性问题的提出</h4><p>● 是否对各个数学分支都能建立一套形式化的公理系统，使得所涉及领域内的任何命题，都可通过系统的有限不推导，判断命题是否正确。</p>
<h4 id="存在不可判定命题"><a href="#存在不可判定命题" class="headerlink" title="存在不可判定命题"></a>存在不可判定命题</h4><p>● 在包含初等数论的协调的形式系统中，存在不可判定问题；即，存在一个命题A，无法在该系统内证明A或﹁A为真。</p>
<h4 id="可计算问题转换为判定是否可计算"><a href="#可计算问题转换为判定是否可计算" class="headerlink" title="可计算问题转换为判定是否可计算"></a>可计算问题转换为判定是否可计算</h4><p>● 是否存在这样一种抽象的形式系统，它可以衡量什么问题是可以判定的(可计算的)，什么问题是不可判定的(不可计算的)。</p>
<h4 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h4><p>● 邱奇证明，一般递归函数 同 λ可定义的等价性</p>
<p>● 克林尼证明，图灵可计算 同 λ可定义的等价性</p>
<p>● 邱奇-图灵论题：一个函数是可计算的当且仅当它是图灵可计算的(或λ-可定义的)。</p>
<h2 id="集合与归纳证明-回顾"><a href="#集合与归纳证明-回顾" class="headerlink" title="集合与归纳证明(回顾)"></a>集合与归纳证明(回顾)</h2><h3 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h3><p>● 列举法</p>
<p>● 命题法</p>
<h3 id="集合的基数-势"><a href="#集合的基数-势" class="headerlink" title="集合的基数(势)"></a>集合的基数(势)</h3><p>● 有穷集合</p>
<p>​    AB有穷集，A*B的势等于A的势×B的势</p>
<p>● 可数无穷集合</p>
<p>● 不可数无穷集合</p>
<h3 id="集合关系的定义"><a href="#集合关系的定义" class="headerlink" title="集合关系的定义"></a>集合关系的定义</h3><p>● 集合相等 &lt;—&gt; 集合互相包含</p>
<h3 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h3><h3 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h3><p>● 有序偶(笛卡尔积？)集合</p>
<h3 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h3><p>● 自反性</p>
<p>● 反自反性</p>
<p>● 对称性</p>
<p>● 反对称性</p>
<p>● 传递性</p>
<h3 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h3><p>● 具有自反、对称、传递性质的关系</p>
<h3 id="等价划分与等价类"><a href="#等价划分与等价类" class="headerlink" title="等价划分与等价类"></a>等价划分与等价类</h3><p>● 用等价关系R对集合S进行的划分，每个子集S<sub>i</sub>为一个等价类</p>
<h3 id="关系的合成与闭包"><a href="#关系的合成与闭包" class="headerlink" title="关系的合成与闭包"></a>关系的合成与闭包</h3><p>● 设R为A到B的二元关系，S为B到C的二元关系，R和S的合成关系R○S定义为：</p>
<script type="math/tex; mode=display">
R○S = \{<x,z> | x\in A \land z\in C \land \exist y(y\in B\land xRy\land ySz)\}</script><p>简化形式：</p>
<script type="math/tex; mode=display">
R○S = \{<x,z>|\exist y(xRy\land ySz) \}</script><p>● 闭包</p>
<p>包含<em>给定的元素</em>，并且具有<em>指定性质</em>的<em>最小</em>的集合，称为关系的闭包；这个指定的性质就是关系R</p>
<h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>● 构造无穷集合</p>
<h3 id="归纳证明"><a href="#归纳证明" class="headerlink" title="归纳证明"></a>归纳证明</h3><p>● 证明无穷集合元素均具有P性质</p>
<p>● 如证明$R^<em> = (R^</em>)^* $</p>
<h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p>● 集合A所有子集组成的集合称为A的幂集，记作2<sup>A</sup></p>
<!--在查幂集的时候发现了一个叫叠集的东西，写作2^A,但是在其他地方没有查到。。。不知道是太高深还是民科。。。-->
<h2 id="符号语言"><a href="#符号语言" class="headerlink" title="符号语言"></a>符号语言</h2><h3 id="字母表与字符串"><a href="#字母表与字符串" class="headerlink" title="字母表与字符串"></a>字母表与字符串</h3><h4 id="字母表-amp-字符"><a href="#字母表-amp-字符" class="headerlink" title="字母表&amp;字符"></a>字母表&amp;字符</h4><p> ● 字母表是一个<em>非空有限</em>集合，通常记作$\Sigma$,其中元素称为字母表的字符。</p>
<p>● 字母表及其字符特点：</p>
<p>​    - 字母表具有非空、有穷性</p>
<p>​    - 字符具有不可分性、整体性</p>
<p>​    - 字符具有可区分性、可辨认性</p>
<h4 id="字母表的乘积"><a href="#字母表的乘积" class="headerlink" title="字母表的乘积"></a>字母表的乘积</h4><p>● $\Sigma$1,$\Sigma$2是两个字母表，则$\Sigma$1,$\Sigma$2的乘积定义为：</p>
<script type="math/tex; mode=display">
\Sigma1\Sigma2 = \{ab | a\in\Sigma1 \land b\in\Sigma2\}</script><p>● $\Sigma$是一个字母表，$\Sigma$的n次幂可递归定义为：</p>
<script type="math/tex; mode=display">
\Sigma^0 = \{\xi\};\Sigma^n = \Sigma^{n-1}\Sigma,n\geqslant1</script><p>其中，$\xi$表示$\Sigma$由0个字符(空字符)组成。</p>
<h4 id="正闭包-amp-克林闭包"><a href="#正闭包-amp-克林闭包" class="headerlink" title="正闭包&amp;克林闭包"></a>正闭包&amp;克林闭包</h4><p>$\Sigma$是一个字母表，</p>
<p>● 正闭包：</p>
<script type="math/tex; mode=display">
\Sigma = \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup ...</script><p>● 克林闭包</p>
<script type="math/tex; mode=display">
\Sigma = \Sigma^0 \cup \Sigma^1 \cup \Sigma^2 \cup \Sigma^3 \cup ...</script><p>是$\Sigma$上全体字符串组成的集合</p>
<h3 id="符号语言及其运算性质"><a href="#符号语言及其运算性质" class="headerlink" title="符号语言及其运算性质"></a>符号语言及其运算性质</h3><h4 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h4><p>● $\Sigma$是一个字母表，$\forall$x$\in$$\Sigma^*$,x叫做$\Sigma$上的一个句子(字符串、符号串)</p>
<p>● 接上，字符串x中字符出现的总个数叫做该串的长度，记作|x|.</p>
<script type="math/tex; mode=display">
|a^n| = n;|a^0| = |\xi| = 0</script><p>● $\alpha$和$\beta$是任意两个字符串，则</p>
<p>​    $\alpha$ = $\beta$    当且仅当     |$\alpha$| = |$\beta$| 且 组成$\alpha$的字符与组成$\beta$的字符依次对应相同</p>
<h4 id="句子的连接-amp-幂运算"><a href="#句子的连接-amp-幂运算" class="headerlink" title="句子的连接&amp;幂运算"></a>句子的连接&amp;幂运算</h4><p>● $\alpha$和$\beta$是$\Sigma$*上任意的两个字符串，$\alpha$和$\beta$的连接构成一个新句子，记作$\alpha \cdot \beta$，该句子由串$\alpha$后直接接串$\beta$组成。</p>
<p>● 对于$n\geq0$，字符串$\alpha$的n次幂为：</p>
<script type="math/tex; mode=display">
(1)\alpha^0 = \xi  ;  (2)\alpha^n = \alpha^{n-1}\alpha</script><h4 id="前缀、后缀-amp-子串"><a href="#前缀、后缀-amp-子串" class="headerlink" title="前缀、后缀&amp;子串"></a>前缀、后缀&amp;子串</h4><p>● $Sigma$是一个字母表，任意字符串x,y,z$\in\Sigma^*$，且x = yz；</p>
<p>​    则称y是x的前缀，z是x的后缀；</p>
<p>​    如果z $\neq\xi$，则称y是x的真前缀；如果y$\neq\xi$，则称z是x的真后缀。</p>
<p>● $\xi$是每个字符串的前缀、后缀、子串</p>
<h4 id="字符串的逆"><a href="#字符串的逆" class="headerlink" title="字符串的逆"></a>字符串的逆</h4><p>● $\omega$ = $a_1a_2…a_n$是任意字符串，称字符串$a_n…a_2a_1$是$\omega$的逆，记作$\omega^T$</p>
<p>● 若$\omega = \omega^T$，则称$\omega$为回文</p>
<h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>● $\Sigma$是任意字母表，$\forall L\subseteq \Sigma^*$，L称为字母表$\Sigma$上的一个语言；</p>
<p>● $\forall x \in L$，x叫做L上的一个句子</p>
<p>● $\Sigma1$和$\Sigma2$是字母表，$L_1\subseteq\Sigma1^<em>$，$L_2 \subseteq \Sigma2^</em>$，L1和L2的乘积</p>
<script type="math/tex; mode=display">
L1L2 = \{xy|x\in L_1 \land y\in L_2\}</script><p>是字母表$\Sigma_1 \cup \Sigma_2$上的一个语言。</p>
<h4 id="判断是否同一语言-amp-加深对语言理解小技巧"><a href="#判断是否同一语言-amp-加深对语言理解小技巧" class="headerlink" title="判断是否同一语言&amp;加深对语言理解小技巧"></a>判断是否同一语言&amp;加深对语言理解小技巧</h4><p>● 观察语言中：</p>
<p>​    1.最短的句子是什么</p>
<p>​     2.比最短句子稍长句子是什么</p>
<p>● 比如比较$L_1 = {0^n1^n0^n|n\geq1}$和$L_2 = {0^n1^m0^k|n,m,k\geq1}$，</p>
<p>​    我们就可以对$L_1L_2$中最短句子和稍长句子进行比较</p>
<script type="math/tex; mode=display">
L_1 : 最短010，稍长001100</script><script type="math/tex; mode=display">
L_2:最短010，稍长0010,0110,0100</script><p>​    很容易就可以发现两者的异同</p>
<h4 id="语言的运算规则"><a href="#语言的运算规则" class="headerlink" title="语言的运算规则"></a>语言的运算规则</h4><p>● 非常多，在此不一一罗列，大体上一部分是三个集合交并补的规则，一部分是正闭包和克林闭包的运算规则和二级结论；以后用到了会补充在此</p>
]]></content>
      <categories>
        <category>study,cs</category>
      </categories>
      <tags>
        <tag>形式语言</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建指南</title>
    <url>/2022/08/24/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>近几日，搭建了自己的博客，简记一下过程。</p>
<p>主要是参考了<a href="https://mp.weixin.qq.com/s/3li0n8REcU1DviwWiEYw_A">超全面！如何用 GitHub 从零开始搭建一个博客 ？ (qq.com)</a>，之后需要注意的是：1.仓库名字要和自己的github用户名保持一致；2.github&amp;settings中emails选项的private要记得勾掉。</p>
<p>这样就可以大概搭建出一个博客的雏形了。</p>
]]></content>
      <categories>
        <category>cs</category>
      </categories>
      <tags>
        <tag>日常知识</tag>
      </tags>
  </entry>
  <entry>
    <title>大三上各门学科考核要求</title>
    <url>/2022/08/30/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%90%84%E9%97%A8%E5%AD%A6%E7%A7%91%E8%80%83%E6%A0%B8%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<h1 id="数据库管理系统原理"><a href="#数据库管理系统原理" class="headerlink" title="数据库管理系统原理"></a>数据库管理系统原理</h1><p>• 考核方式 </p>
<p>​    – 平时成绩 10% </p>
<p>​        • 作业、课堂参与 </p>
<p>​        • 华为云数据库GAUSSDB实验 </p>
<p>​    – 大作业（课程设计） 30% </p>
<p>​    – 期末考试 60% </p>
<p>组队：三人一组</p>
<h1 id="形式语言与自动机"><a href="#形式语言与自动机" class="headerlink" title="形式语言与自动机"></a>形式语言与自动机</h1><p>考察方式： </p>
<p>​    - 平时：作业+课堂参与+论文阅读讲解（30%） </p>
<p>​    - 期末考试（开卷）（70%）</p>
<p>组队：四人一队</p>
<h1 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h1><p>平时：30% </p>
<p>​    - 作业（30% ）</p>
<p> 期末考试：70% </p>
<p>​    - 开卷考试，重在知识点理解</p>
<p>​    - 题量不大</p>
<h1 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h1><p>成绩由两部分组成（暂定比例，有可能微调）： </p>
<p>理论基础(3学分)：课堂教学，按时交作业，占比60% </p>
<p>​    – 作业，10分，每周一提交前一周作业 </p>
<p>​    – 3-6次随堂考试，共计30分</p>
<p>​     – 期末闭卷考试，60分 </p>
<p>​    – 主动回答问题，每次奖励0.5分，5分封顶（考前公布） </p>
<p>实践部分(2学分)：</p>
<p>​    - 上机实践（50机时），占比40% – 12月底检查作业</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
  </entry>
  <entry>
    <title>大三上学习规划</title>
    <url>/2022/08/26/%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>—人的一生之精彩，在于自己追逐梦想的过程，不必苛求旁人的不失望或者喜欢。走自己的路，让旁人失望和不喜欢去吧！</p>
<p>在上一篇博客里，我对自己的思想问题进行了一个回顾和总结，在本篇博客里，我准备对大三上的学习进行前瞻和计划。</p>
<p>首先是学校课程，大三上有三门核心专业课、五门一般专业课(待抽签)、一门一般通识课和一门体育课。由于对于具体的课程要求不清楚，所以我在这只做具体的要求：</p>
<p>认真听课，不要摸鱼开车，上课的知识很重要；</p>
<p>认真完成作业，不要像上学期的概统一样；</p>
<p>及时回顾复习，上过一门课之后要把当堂的重点归纳总结，既是对本堂课内容的复习，也是为自己日后复习积累资料。</p>
<p>我相信，无论是哪门课，只要我做到这些点，一定可以学好这门课的知识、得到一个不错的成绩。</p>
<p>接下来是自己的其他规划，由于大三上应该会很忙，所以我主要以学校的课程为主，除了课程之外的要求暂时只想到两点：</p>
<p>c++语言在十二月之前提升到一个可观的水平，刷ccf csp的题目，争取在十二月的考试中获得300分以上的成绩。</p>
<p>体育锻炼，一小时锻炼方案：三公里+拉伸+俯卧撑+拉伸；四十分钟锻炼方案：俯卧撑+拉伸；七十五分钟锻炼方案：四公里+拉伸+俯卧撑+拉伸。根据时间多少对俯卧撑数目进行加减、适当增加卷腹。</p>
<p>大体的方案就是这样，更具体的实施办法等到实施的时候会进一步完善</p>
<p>—(σﾟ∀ﾟ)σ..:*☆哎哟不错哦</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>实迷途其未远</title>
    <url>/2022/08/25/%E5%AE%9E%E8%BF%B7%E9%80%94%E5%85%B6%E6%9C%AA%E8%BF%9C/</url>
    <content><![CDATA[<p>—something for nothing</p>
<p>最近因为疫情急忙从家赶到学校，比正常开学早了一个礼拜，有了一段既想做点什么、又不知道学什么的时间，正好用来打量打量自己。</p>
<p>大学的时光过得真快啊，快得我感觉自己还是两年前刚进校的青年，感觉什么都没有学到就要毕业了。如果是高中，现在的我正好处在那个人生转折的高二暑假，发生的种种正强烈冲击我的内心；可在大学的大二暑假，我什么都没有感觉到，每天学驾照、健身、玩手机，生活显得安逸且适足。</p>
<p>但在这安逸的生活下，其实有着种种关于学习的隐忧：我上个学期的成绩并不算理想，严重拉低了我的GPA；我对学过的课还从来没进行过复习，相关课程知识掌握的不熟练可能是之后研究生面试、实习生面试的伏笔；我还没有进过实验室，没有科研经验，可能又是一个研究生的伏笔；我对于c和c++语言的掌握还不够，将来的机试可能会出问题，而我的时间已经不多了……</p>
<p>面对这么多的问题和麻烦，我选择什么都不管，照样学驾照、健身、玩手机，舒舒服服地过了一个暑假，现在想想，也没什么负罪感^_^。</p>
<p>但是问题是不会消失的，随着新学期的开始，这些问题都亟待着我去解决，首先要解决的第一个大问题，就是思想问题。</p>
<p>回首大学的两年学习，大一一年其实我是在凭借着高中的惯性在继续前进，凭借之前的数理基础和“哀兵”的心理，整个大一的状态和成绩我还是比较认可的；大二开始心态就先出现了问题，时间会渐渐冲淡过去的不甘，而面对自己不熟悉的计算机专业课程难免有畏难、迷茫情绪，所以大二上的学习状态就已经不如大一，但是由于大二上课程数量少、有我擅长的物理，所以最后成绩还算不错；大二下则是问题的一个爆发，首先是心态上更加怠惰，然后是进一步增加的专业课、凑热闹的荣誉课，两者一内一外把我的状态搅得一团糟，虽然出于对自己的要求也在努力学习，但是用时间学习和用心学习是两回事，最终专业课的知识没学好、荣誉课的成绩不理想，大二下可以说是比较失败了。</p>
<p>刨除我不能改变的排课不合理这一外部因素，造成我失败的原因就是我的心态问题，我逐渐没有那么想学习了，总是把学习物化成分数和绩点，而对学习新知识的过程嗤之以鼻，这就导致学习新知识很难给我带来快乐，只有看到成绩单的数字才能给我快乐。但是学习的过程不快乐就意味着我很难坚持去学一门硬课，只能凭着自己的意志死磕，而成绩往往是在最后才知道，这时已经于事无补。</p>
<p>那么为什么会变成这样呢？其实在大一入学的时候，我告诉自己忘了过去，好好做人，知识和分数我都要，所以哪怕一些课给分不太高，我也愿意去上。但是随着时间的推移，大家聊天的时候主要在谈论成绩和排名，给分不高的课确实让我受到了一些损害，我发现大学和高中也没有什么不同，都是怀着学知识的心进来，慢慢地变得只盯着分数看。作为自认为已经被理想背叛了一次的我来说，怀着一种小孩子报复的快感，我说：那我也只盯着分数看好了。</p>
<p>但这样，真的对吗？真的是理想背叛了我吗？我以前觉得是，现在我觉得不是。</p>
<p>我以前觉得心有多大，舞台就有多大，心中有爱和正义的少年一定能成功到达梦想的彼岸；现在我发现，确实是心有多大，舞台就有多大，但是不是充分条件，是必要条件，心灵规划的舞台是你的上限而不是你的下限，确定了心的目标还要辅以正确的方法，才能达到想去的远方，就比如说我之前锻炼一直凭着一股蛮劲在练，我觉得只要我多跑步多运动我身材就会好，但是这个暑假我了解之后才发现不是如此，跑步不仅掉脂肪，还掉肌肉，想要有一个好身材一定要既做有氧又做力量，之后我再去练，一个多月就瘦了十斤，而且肌肉的线条也更明显了。能说之前的我不想有一个好身材吗，但是方法错了，就是事半功倍甚至南辕北辙，而每一件事都有它相对应的方法，只有找到了正确的方法再去努力才能接近目标。现在想想，学习和锻炼是很有误导性的两个工作，对于这两个工作来说，你只要心到位了，努力的方向不对，可能走得慢，但一定在走；但是其他事情可不一定如此，就比如说我这个暑假去学了几节唱歌，我发现如果你不按正确的方法练习，你练得再多，也没有用，反而会形成错误的肌肉记忆，跟人相关的就更不用说了。</p>
<p>与之相对应的如果心到不了的地方，人也一定到不了。我自己都觉得我这门课学不好，那我一定就学不好，因为我不会了我不会去查资料、问同学、问老师，我告诉自己学到这样就可以了，剩下的是给更强的人准备的，这样最后的成果会好吗？一定不会。</p>
<p>上个学期马原课上听老师说，哲学的基本规律之一是否定之否定规律，越想越觉得有道理，我好像又可以相信爱与正义了。但这个爱和正义与我当年相信的不同，我当年是无条件地相信爱和正义，现在是有条件的，不是我加的条件，世界加的，他告诉我：爱是需要代价的，正义也是需要代价的。</p>
<p>但我又好像走不出18岁的阴霾，那天的教室后排和那天的大雨，我好像忘了，又好像没忘。我就是这样，知易行难，还是交给时间吧。</p>
<p>但我知道的是我能从上个学期的阴霾走出来了，至少，我的求知心和奋斗心又回来了，具体的规划下一篇blog再说吧，再写就多的不礼貌了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>生活感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>optimization</title>
    <url>/2022/09/01/optimization-1/</url>
    <content><![CDATA[<h1 id="线性规划基本原理与基本算法"><a href="#线性规划基本原理与基本算法" class="headerlink" title="线性规划基本原理与基本算法"></a>线性规划基本原理与基本算法</h1><h2 id="最优化方法的基本模型"><a href="#最优化方法的基本模型" class="headerlink" title="最优化方法的基本模型"></a>最优化方法的基本模型</h2><h3 id="最优化问题的思路"><a href="#最优化问题的思路" class="headerlink" title="最优化问题的思路"></a>最优化问题的思路</h3><p>● 可能的决策方案</p>
<p>● 限制条件</p>
<p>● 目标的评判标准</p>
<h3 id="最优化模型"><a href="#最优化模型" class="headerlink" title="最优化模型"></a>最优化模型</h3><p>● 可行解：满足所有约束条件的模型的解</p>
<p>● 不可行解：</p>
<p>● 最优解：可行解的基础上，取得了目标函数的最佳值</p>
<h4 id="最优化模型表示的通用格式"><a href="#最优化模型表示的通用格式" class="headerlink" title="最优化模型表示的通用格式"></a>最优化模型表示的通用格式</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">min或max    目标函数</span><br><span class="line">s.t.    约束条件</span><br></pre></td></tr></table></figure>
<h2 id="最优化方法的基本步骤"><a href="#最优化方法的基本步骤" class="headerlink" title="最优化方法的基本步骤"></a>最优化方法的基本步骤</h2><p>● 问题定义 —&gt; 模型构造 —&gt; 模型求解 —&gt; 模型验证</p>
<h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>● 找出最优化问题的三个因素</p>
<p>​    ◇ 可能的决策方案</p>
<p>​    ◇ 限制条件</p>
<p>​    ◇ 最优化目标</p>
<h3 id="模型构造"><a href="#模型构造" class="headerlink" title="模型构造"></a>模型构造</h3><p>● 将问题定义转换为数学关系，将要产生的模型成为某种数学模型：</p>
<p>​    ◇ 线性规划</p>
<p>​    ◇ 整数规划、动态规划、网络规划</p>
<p>​    ◇ 非线性规划</p>
<h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p>● 利用成熟的最优化算法进行求解</p>
<p>● 灵敏度分析：了解当模型参数改变时，最优解会有怎样的表现</p>
<h3 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h3><p>● 一般方法：把模型的输出结果与历史的输出结果进行比较</p>
<p>● 判断标准：如果模型是基于对历史数据的仔细分析，输出结果应该优于历史结果</p>
<h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h3 id="二维变量的线性规划模型"><a href="#二维变量的线性规划模型" class="headerlink" title="二维变量的线性规划模型"></a>二维变量的线性规划模型</h3><p>● 寻找并确定决策变量</p>
<p>● 优化(求极大或极小的)目标函数</p>
<p>● 解必须满足的约束条件</p>
<h3 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h3><p>● 可行解空间</p>
<p>● 可行点 —&gt; 最优解</p>
<h3 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h3>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>最优化</tag>
      </tags>
  </entry>
</search>
